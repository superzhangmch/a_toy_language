以往也自学过编译原理, 一直没时间亲手打造一个(曾做一半, 但半途而废). 现在借手 AI, 做一个自娱, 且用以跟着 ai 老师自学. 

----

一般地, 先走 lexer + parse, 得到语法树(AST), 这之后要么走解析执行, 要么是编译成二进制. 

- lexer: 解析成 [token_type, position_in_source_code] 组成的token 数组
- parse: 基于 lexer 结果, 解析成 AST
- 执行:
  * 对于 interpreter, loop 或 条件执行, 可以借助寄生语言的循环/if 判断.
  * 对于要编译成二进制的: 如果不是自己写代码生成,
    - 一种方式是直接转化成另外一种语言(有如 C++ 编译器曾就是先编译成 c, 再用 c compiler)
    - 还可以借助于 LLVM 这样的东西, 先翻译成 LLVM 的 IR 中间表示

----

### parser

有两大类别, 从底向上(yacc/bison 的 LALR(1) 算法就用此) 或 从上往下递归(这里 py 实现用此).

对于 LALR(1) 来说, 自底向上分析语法，每一步只看 1 个未来符号，看起来应该很弱——毕竟复杂语句可能需要好多个 token. 实际上这是误解: 它线性扫描过程中, 会记录状态, 从而下一步预期可以接受的 token 类型是有限的. 一旦不再预期内, 就是语法犯规; 否则 shift 看下一个, 直到认为一个完整语句被识别出(reduce), 大体上来说, 它其实就是提前构建了一个状态机, 按状态机指示往下走而已. 最终它的本质仍是构建语法树.

LALR(1) 不是“只靠 1 个 token 做判断”，而是“用整个历史（状态栈）+ 1 个 token 做判断”. 句子可能很长, 怎么只看 1 个 token 就够？这里的误区是把 lookahead 当成了 全部信息。LR / LALR parser 不是无脑往前看，而是：把 “已经看到的结构”, 压缩成一个 有限状态. 这就是自动机的本质。

当 parser 看到 else 时：状态栈表明 `当前在 “内层 if 的 stmt 已完成，但外层还没”`, 则其实parser 知道现在是在 if-else 语句中. 故而是: 状态 + lookahead 唯一决定动作.

自然语言没法用 LALR来解析: 
```
比如: I saw the man with a telescope. 用望远镜看到了那个人？ 看到一个拿着望远镜的人？ 无法唯一解析, 有 shift/reduce 冲突
```

### llvm ir

LLVM IR 是一种 虚拟机级别的 SSA 形式汇编语言. 

LLVM IR **长得很像汇编**，比如：

```llvm
%1 = add i32 %a, %b
br label %loop
```

它有：

* 显式指令（add / load / store / br）
* 显式控制流（basic block + branch）
* 明确的数据类型（i32 / float / ptr）

👉 从“**形式**”上看，它确实是汇编风格的。

但它**不是 CPU 的汇编**：

| 对比点  | CPU 汇编                | LLVM IR    |
| ---- | --------------------- | ---------- |
| 面向对象 | конкрет 硬件（x86 / ARM） | 虚拟机        |
| 寄存器  | 真实寄存器                 | 无限虚拟寄存器    |
| 指令   | 和硬件强绑定                | 抽象、平台无关    |
| 语义   | 非常贴近硬件                | 保留较多“高级语义” |

👉 所以它**不是 machine assembly，而是 IR assembly**。

它的核心特点（重点）

1️⃣ SSA（Static Single Assignment）——最关键的特点

LLVM IR **强制使用 SSA 形式**：

* 每个“变量”只赋值一次
* 控制流汇合处用 `phi` 指令

```llvm
if.then:
  %x1 = add i32 %a, 1
  br label %merge

if.else:
  %x2 = sub i32 %a, 1
  br label %merge

merge:
  %x = phi i32 [%x1, %if.then], [%x2, %if.else]
```

🔹 好处：

* 数据依赖极其清晰
* 非常利于优化（DCE / CSE / LICM / GVN）

2️⃣ 强类型（Strongly Typed）

LLVM IR 是**强类型系统**：

```llvm
add i32 %a, %b   ; 合法
add i32 %a, %f   ; ❌ 类型错误
```

* 所有值都有类型
* 指针类型显式（`i32*`、`ptr`）
* 类型错误在 IR 级就能发现

👉 比汇编“高级”，比 C 还严格。

3️⃣ 无限虚拟寄存器

```llvm
%1 = ...
%2 = ...
%10086 = ...
```

* 不考虑真实寄存器数量
* 寄存器分配推迟到 **Backend**

👉 前端 / 中端优化完全不用管寄存器压力。

4️⃣ 平台无关（Target-independent）

同一份 LLVM IR 可以：

* → x86
* → ARM
* → RISC-V
* → GPU（部分）

```text
C / Rust / Swift
   ↓
 LLVM IR
   ↓
 x86 / ARM / ...
```

👉 这是 LLVM 生态成功的根本原因之一。


5️⃣ 为“优化”而生，而不是为“执行”而生

LLVM IR 的设计目标不是直接跑得快，而是：

> **“让编译器分析和变换变得极其容易”**

比如：

* 显式 basic block
* 显式 CFG
* 显式内存模型（load/store）
* 清晰的 side-effect 规则

6️⃣ 多种形态：文本 / Bitcode / 内存对象

LLVM IR 有三种存在形式：

1. **文本 IR（`.ll`）**
   👉 给人看的
2. **Bitcode（`.bc`）**
   👉 给工具链用
3. **内存中的 IR 对象**
   👉 给 Pass 用

它们**语义完全一致**。

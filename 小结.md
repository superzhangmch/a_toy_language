以往也自学过编译原理, 一直没时间亲手打造一个(曾做一半, 但半途而废). 现在借手 AI, 做一个自娱, 且用以跟着 ai 老师自学. 

----

一般地, 先走 lexer + parse, 得到语法树(AST), 这之后要么走解析执行, 要么是编译成二进制. 

- lexer: 解析成 [token_type, position_in_source_code] 组成的token 数组
- parse: 基于 lexer 结果, 解析成 AST
- 执行:
  * 对于 interpreter, loop 或 条件执行, 可以借助寄生语言的循环/if 判断.
  * 对于要编译成二进制的: 如果不是自己写代码生成,
    - 一种方式是直接转化成另外一种语言(有如 C++ 编译器曾就是先编译成 c, 再用 c compiler)
    - 还可以借助于 LLVM 这样的东西, 先翻译成 LLVM 的 IR 中间表示

----

### parser

有两大类别, 从底向上(yacc/bison 的 LALR(1) 算法就用此) 或 从上往下递归(这里 py 实现用此).

对于 LALR(1) 来说, 自底向上分析语法，每一步只看 1 个未来符号，看起来应该很弱——毕竟复杂语句可能需要好多个 token. 实际上这是误解: 它线性扫描过程中, 会记录状态, 从而下一步预期可以接受的 token 类型是有限的. 一旦不再预期内, 就是语法犯规; 否则 shift 看下一个, 直到认为一个完整语句被识别出(reduce), 大体上来说, 它其实就是提前构建了一个状态机, 按状态机指示往下走而已. 最终它的本质仍是构建语法树.

自然语言没法用 LALR来解析: 
```
比如: I saw the man with a telescope. 用望远镜看到了那个人？ 看到一个拿着望远镜的人？ 无法唯一解析, 有 shift/reduce 冲突
```
